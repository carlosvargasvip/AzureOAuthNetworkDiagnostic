<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Azure OAuth Network Diagnostic Tool</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-primary: #0a0e17;
    --bg-secondary: #111827;
    --bg-card: #161f33;
    --bg-card-hover: #1c2740;
    --border: #1e2d4a;
    --border-active: #2563eb;
    --text-primary: #e2e8f0;
    --text-secondary: #8899b4;
    --text-muted: #4a5b78;
    --accent-blue: #3b82f6;
    --accent-cyan: #06b6d4;
    --accent-green: #10b981;
    --accent-red: #ef4444;
    --accent-yellow: #f59e0b;
    --accent-orange: #f97316;
    --accent-purple: #8b5cf6;
    --glow-blue: rgba(59, 130, 246, 0.15);
    --glow-green: rgba(16, 185, 129, 0.15);
    --glow-red: rgba(239, 68, 68, 0.15);
    --mono: 'JetBrains Mono', monospace;
    --sans: 'IBM Plex Sans', sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--sans);
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Background grid effect */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      linear-gradient(rgba(59, 130, 246, 0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 1200px;
    margin: 0 auto;
    padding: 24px 20px 60px;
  }

  /* Header */
  .header {
    text-align: center;
    padding: 40px 0 32px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 32px;
  }

  .header-badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: rgba(59, 130, 246, 0.1);
    border: 1px solid rgba(59, 130, 246, 0.25);
    border-radius: 20px;
    padding: 6px 16px;
    font-family: var(--mono);
    font-size: 11px;
    color: var(--accent-blue);
    letter-spacing: 1.5px;
    text-transform: uppercase;
    margin-bottom: 16px;
  }

  .header-badge .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent-blue);
    animation: pulse-dot 2s ease infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .header h1 {
    font-size: 28px;
    font-weight: 700;
    letter-spacing: -0.5px;
    margin-bottom: 8px;
    background: linear-gradient(135deg, #e2e8f0 0%, #3b82f6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .header p {
    color: var(--text-secondary);
    font-size: 14px;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
  }

  /* Control bar */
  .control-bar {
    display: flex;
    gap: 12px;
    align-items: center;
    justify-content: center;
    margin-bottom: 32px;
    flex-wrap: wrap;
  }

  .btn {
    font-family: var(--sans);
    font-size: 13px;
    font-weight: 600;
    padding: 10px 24px;
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }

  .btn-primary {
    background: var(--accent-blue);
    border-color: var(--accent-blue);
    color: white;
  }

  .btn-primary:hover {
    background: #2563eb;
    box-shadow: 0 0 24px rgba(59, 130, 246, 0.3);
  }

  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
  }

  .btn-secondary {
    background: var(--bg-card);
    color: var(--text-primary);
  }

  .btn-secondary:hover {
    background: var(--bg-card-hover);
    border-color: var(--text-muted);
  }

  .btn-danger {
    background: rgba(239, 68, 68, 0.1);
    border-color: rgba(239, 68, 68, 0.3);
    color: var(--accent-red);
  }

  .btn-danger:hover {
    background: rgba(239, 68, 68, 0.2);
  }

  .spinner {
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  /* Progress bar */
  .progress-container {
    margin-bottom: 24px;
    display: none;
  }

  .progress-container.active { display: block; }

  .progress-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 12px;
    color: var(--text-secondary);
    font-family: var(--mono);
  }

  .progress-bar {
    height: 4px;
    background: var(--bg-card);
    border-radius: 4px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
  }

  /* Summary cards */
  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 28px;
    display: none;
  }

  .summary-grid.active { display: grid; }

  .summary-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    text-align: center;
  }

  .summary-card .count {
    font-size: 32px;
    font-weight: 700;
    font-family: var(--mono);
    line-height: 1;
    margin-bottom: 4px;
  }

  .summary-card .label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-secondary);
  }

  .count-pass { color: var(--accent-green); }
  .count-fail { color: var(--accent-red); }
  .count-warn { color: var(--accent-yellow); }
  .count-total { color: var(--accent-blue); }

  /* Environment info */
  .env-bar {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
    margin-bottom: 24px;
    display: none;
  }

  .env-bar.active { display: block; }

  .env-bar h3 {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
    margin-bottom: 12px;
  }

  .env-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 8px;
  }

  .env-item {
    display: flex;
    gap: 8px;
    font-size: 12px;
    font-family: var(--mono);
  }

  .env-item .key {
    color: var(--text-muted);
    white-space: nowrap;
  }

  .env-item .val {
    color: var(--text-primary);
    word-break: break-all;
  }

  /* Test sections */
  .test-section {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 12px;
    margin-bottom: 16px;
    overflow: hidden;
    transition: border-color 0.3s;
  }

  .test-section.result-pass { border-left: 3px solid var(--accent-green); }
  .test-section.result-fail { border-left: 3px solid var(--accent-red); }
  .test-section.result-warn { border-left: 3px solid var(--accent-yellow); }

  .section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s;
  }

  .section-header:hover { background: var(--bg-card-hover); }

  .section-title-area {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .status-icon {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-weight: 700;
    flex-shrink: 0;
  }

  .status-pending {
    background: rgba(75, 85, 99, 0.3);
    border: 1px solid #4b5563;
    color: #9ca3af;
  }

  .status-running {
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid var(--accent-blue);
    color: var(--accent-blue);
    animation: pulse-dot 1s ease infinite;
  }

  .status-pass {
    background: rgba(16, 185, 129, 0.15);
    border: 1px solid var(--accent-green);
    color: var(--accent-green);
  }

  .status-fail {
    background: rgba(239, 68, 68, 0.15);
    border: 1px solid var(--accent-red);
    color: var(--accent-red);
  }

  .status-warn {
    background: rgba(245, 158, 11, 0.15);
    border: 1px solid var(--accent-yellow);
    color: var(--accent-yellow);
  }

  .section-title h3 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 2px;
  }

  .section-title p {
    font-size: 11px;
    color: var(--text-muted);
  }

  .section-timing {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .chevron {
    transition: transform 0.2s;
    color: var(--text-muted);
  }

  .chevron.open { transform: rotate(180deg); }

  .section-body {
    display: none;
    padding: 0 20px 16px;
    border-top: 1px solid var(--border);
  }

  .section-body.open {
    display: block;
    padding-top: 16px;
  }

  /* Detail tables */
  .detail-group {
    margin-bottom: 16px;
  }

  .detail-group-title {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--accent-cyan);
    margin-bottom: 8px;
    font-weight: 600;
  }

  .detail-table {
    width: 100%;
    border-collapse: collapse;
  }

  .detail-table tr {
    border-bottom: 1px solid rgba(30, 45, 74, 0.5);
  }

  .detail-table tr:last-child { border-bottom: none; }

  .detail-table td {
    padding: 6px 0;
    font-size: 12px;
    font-family: var(--mono);
    vertical-align: top;
  }

  .detail-table td:first-child {
    color: var(--text-muted);
    width: 200px;
    padding-right: 16px;
    white-space: nowrap;
  }

  .detail-table td:last-child {
    color: var(--text-primary);
    word-break: break-all;
  }

  .tag {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    font-family: var(--mono);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .tag-pass { background: rgba(16, 185, 129, 0.15); color: var(--accent-green); border: 1px solid rgba(16, 185, 129, 0.3); }
  .tag-fail { background: rgba(239, 68, 68, 0.15); color: var(--accent-red); border: 1px solid rgba(239, 68, 68, 0.3); }
  .tag-warn { background: rgba(245, 158, 11, 0.15); color: var(--accent-yellow); border: 1px solid rgba(245, 158, 11, 0.3); }
  .tag-info { background: rgba(59, 130, 246, 0.15); color: var(--accent-blue); border: 1px solid rgba(59, 130, 246, 0.3); }

  /* Findings panel */
  .findings-panel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    margin-top: 24px;
    display: none;
  }

  .findings-panel.active { display: block; }

  .findings-panel h2 {
    font-size: 16px;
    font-weight: 700;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .finding-item {
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 8px;
    font-size: 13px;
    line-height: 1.6;
  }

  .finding-critical {
    background: rgba(239, 68, 68, 0.08);
    border: 1px solid rgba(239, 68, 68, 0.2);
    color: #fca5a5;
  }

  .finding-warning {
    background: rgba(245, 158, 11, 0.08);
    border: 1px solid rgba(245, 158, 11, 0.2);
    color: #fcd34d;
  }

  .finding-info {
    background: rgba(59, 130, 246, 0.08);
    border: 1px solid rgba(59, 130, 246, 0.2);
    color: #93c5fd;
  }

  .finding-item strong {
    display: block;
    margin-bottom: 2px;
  }

  /* Raw log */
  .raw-log {
    background: #0d1117;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    font-family: var(--mono);
    font-size: 11px;
    color: #8b949e;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
    margin-top: 16px;
    display: none;
  }

  .raw-log.active { display: block; }

  .raw-log .log-pass { color: var(--accent-green); }
  .raw-log .log-fail { color: var(--accent-red); }
  .raw-log .log-warn { color: var(--accent-yellow); }
  .raw-log .log-info { color: var(--accent-cyan); }
  .raw-log .log-time { color: var(--text-muted); }

  /* Export area */
  .export-area {
    margin-top: 24px;
    display: none;
    text-align: center;
  }

  .export-area.active {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  /* Responsive */
  @media (max-width: 640px) {
    .container { padding: 16px 12px 40px; }
    .header h1 { font-size: 22px; }
    .summary-grid { grid-template-columns: repeat(2, 1fr); }
    .env-grid { grid-template-columns: 1fr; }
    .detail-table td:first-child { width: 120px; }
  }

  /* Raw Request/Response panels */
  .raw-toggle {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 5px 12px;
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 600;
    color: var(--accent-cyan);
    background: rgba(6, 182, 212, 0.08);
    border: 1px solid rgba(6, 182, 212, 0.2);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
    margin-right: 8px;
    margin-bottom: 8px;
  }

  .raw-toggle:hover {
    background: rgba(6, 182, 212, 0.15);
    border-color: rgba(6, 182, 212, 0.4);
  }

  .raw-toggle.active {
    background: rgba(6, 182, 212, 0.15);
    border-color: var(--accent-cyan);
  }

  .raw-panel {
    display: none;
    margin-top: 8px;
    margin-bottom: 16px;
  }

  .raw-panel.open { display: block; }

  .raw-block {
    background: #080c14;
    border: 1px solid rgba(30, 45, 74, 0.6);
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 10px;
  }

  .raw-block-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 14px;
    background: rgba(30, 45, 74, 0.3);
    border-bottom: 1px solid rgba(30, 45, 74, 0.6);
  }

  .raw-block-label {
    font-family: var(--mono);
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
  }

  .raw-block-label.req { color: var(--accent-blue); }
  .raw-block-label.res { color: var(--accent-green); }
  .raw-block-label.res-err { color: var(--accent-red); }

  .raw-block-meta {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-muted);
  }

  .raw-block-body {
    padding: 12px 14px;
    font-family: var(--mono);
    font-size: 11px;
    line-height: 1.65;
    color: #8b9dc3;
    max-height: 500px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
    tab-size: 2;
  }

  .raw-block-body .http-method { color: var(--accent-blue); font-weight: 700; }
  .raw-block-body .http-url { color: var(--text-primary); }
  .raw-block-body .http-version { color: var(--text-muted); }
  .raw-block-body .http-status-ok { color: var(--accent-green); font-weight: 700; }
  .raw-block-body .http-status-err { color: var(--accent-red); font-weight: 700; }
  .raw-block-body .http-status-warn { color: var(--accent-yellow); font-weight: 700; }
  .raw-block-body .header-name { color: var(--accent-cyan); }
  .raw-block-body .header-value { color: #c4cfe0; }
  .raw-block-body .body-separator { color: var(--text-muted); }
  .raw-block-body .body-content { color: #7a8ba8; }
  .raw-block-body .body-truncated { color: var(--accent-yellow); font-style: italic; }

  .raw-copy-btn {
    padding: 3px 10px;
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-muted);
    background: rgba(30, 45, 74, 0.4);
    border: 1px solid rgba(30, 45, 74, 0.6);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .raw-copy-btn:hover {
    color: var(--text-primary);
    background: rgba(30, 45, 74, 0.7);
  }

  .raw-toggles-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 0;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(30, 45, 74, 0.4);
  }

  /* Proxy detection panel */
  .proxy-panel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 12px;
    margin-bottom: 16px;
    overflow: hidden;
    display: none;
  }

  .proxy-panel.active { display: block; }

  .proxy-panel.proxy-detected { border-left: 3px solid var(--accent-yellow); }
  .proxy-panel.proxy-clear { border-left: 3px solid var(--accent-green); }
  .proxy-panel.proxy-error { border-left: 3px solid var(--accent-red); }

  .proxy-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    cursor: pointer;
    user-select: none;
  }

  .proxy-header:hover { background: var(--bg-card-hover); }

  .proxy-title-area {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .proxy-body {
    display: none;
    padding: 0 20px 16px;
    border-top: 1px solid var(--border);
  }

  .proxy-body.open {
    display: block;
    padding-top: 16px;
  }

  .proxy-check-row {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px solid rgba(30, 45, 74, 0.4);
    font-size: 12px;
  }

  .proxy-check-row:last-child { border-bottom: none; }

  .proxy-check-icon {
    flex-shrink: 0;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    margin-top: 1px;
  }

  .pci-detected {
    background: rgba(245, 158, 11, 0.15);
    border: 1px solid var(--accent-yellow);
    color: var(--accent-yellow);
  }

  .pci-clear {
    background: rgba(16, 185, 129, 0.15);
    border: 1px solid var(--accent-green);
    color: var(--accent-green);
  }

  .pci-error {
    background: rgba(239, 68, 68, 0.15);
    border: 1px solid var(--accent-red);
    color: var(--accent-red);
  }

  .pci-info {
    background: rgba(59, 130, 246, 0.15);
    border: 1px solid var(--accent-blue);
    color: var(--accent-blue);
  }

  .proxy-check-content {
    flex: 1;
  }

  .proxy-check-name {
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 2px;
  }

  .proxy-check-detail {
    color: var(--text-secondary);
    font-family: var(--mono);
    font-size: 11px;
    line-height: 1.5;
    word-break: break-all;
  }
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <div class="header-badge"><span class="dot"></span> Network Diagnostic</div>
    <h1>Azure OAuth Network Diagnostic</h1>
    <p>Tests connectivity, headers, SSL inspection, and redirect behavior across all Microsoft authentication and Graph API endpoints from your current network.</p>
  </div>

  <div class="control-bar">
    <button class="btn btn-primary" id="btnRun" onclick="runAllTests()">
      ▶ Run Full Diagnostic
    </button>
    <button class="btn btn-secondary" id="btnLog" onclick="toggleRawLog()">
      ◈ Toggle Raw Log
    </button>
    <button class="btn btn-secondary" id="btnExportJson" onclick="exportJSON()" style="display:none">
      ↓ Export JSON
    </button>
    <button class="btn btn-secondary" id="btnExportText" onclick="exportText()" style="display:none">
      ↓ Export Report
    </button>
    <button class="btn btn-danger" id="btnCopy" onclick="copyReport()" style="display:none">
      ⎘ Copy to Clipboard
    </button>
  </div>

  <div class="progress-container" id="progressContainer">
    <div class="progress-info">
      <span id="progressLabel">Initializing...</span>
      <span id="progressCount">0/0</span>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="summary-grid" id="summaryGrid">
    <div class="summary-card">
      <div class="count count-total" id="sumTotal">0</div>
      <div class="label">Tests Run</div>
    </div>
    <div class="summary-card">
      <div class="count count-pass" id="sumPass">0</div>
      <div class="label">Passed</div>
    </div>
    <div class="summary-card">
      <div class="count count-warn" id="sumWarn">0</div>
      <div class="label">Warnings</div>
    </div>
    <div class="summary-card">
      <div class="count count-fail" id="sumFail">0</div>
      <div class="label">Failed</div>
    </div>
  </div>

  <div class="env-bar" id="envBar">
    <h3>Environment Information</h3>
    <div class="env-grid" id="envGrid"></div>
  </div>

  <div class="proxy-panel" id="proxyPanel">
    <div class="proxy-header" onclick="toggleProxyPanel()">
      <div class="proxy-title-area">
        <div class="status-icon status-pending" id="proxyStatusIcon">◦</div>
        <div class="section-title">
          <h3>Proxy & Network Interception Detection</h3>
          <p>WPAD/PAC, WebRTC, IP analysis, timing differentials, header inspection</p>
        </div>
      </div>
      <div class="section-timing">
        <span id="proxyTiming">—</span>
        <span class="chevron" id="proxyChev">▾</span>
      </div>
    </div>
    <div class="proxy-body" id="proxyBody">
      <div id="proxyChecks"></div>
    </div>
  </div>

  <div id="testSections"></div>

  <div class="findings-panel" id="findingsPanel">
    <h2>⚑ Diagnostic Findings</h2>
    <div id="findingsList"></div>
  </div>

  <div class="raw-log" id="rawLog"></div>
</div>

<script>
const RESULTS = {
  environment: {},
  tests: [],
  findings: [],
  timestamp: null,
  summary: { total: 0, pass: 0, warn: 0, fail: 0 }
};

// All endpoints to test
const ENDPOINTS = [
  {
    id: 'login-ms',
    name: 'login.microsoftonline.com',
    desc: 'Primary Azure AD Authentication',
    url: 'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration',
    critical: true,
    category: 'auth'
  },
  {
    id: 'login-ms2',
    name: 'login.microsoft.com',
    desc: 'Secondary Authentication Endpoint',
    url: 'https://login.microsoft.com/common/v2.0/.well-known/openid-configuration',
    critical: true,
    category: 'auth'
  },
  {
    id: 'device-login',
    name: 'device.login.microsoftonline.com',
    desc: 'Device Code Flow Authentication',
    url: 'https://device.login.microsoftonline.com/',
    critical: true,
    category: 'auth'
  },
  {
    id: 'graph-api',
    name: 'graph.microsoft.com',
    desc: 'Microsoft Graph API',
    url: 'https://graph.microsoft.com/v1.0/$metadata',
    critical: true,
    category: 'api'
  },
  {
    id: 'graph-beta',
    name: 'graph.microsoft.com (beta)',
    desc: 'Microsoft Graph Beta API',
    url: 'https://graph.microsoft.com/beta/$metadata',
    critical: false,
    category: 'api'
  },
  {
    id: 'sts-windows',
    name: 'sts.windows.net',
    desc: 'Security Token Service',
    url: 'https://sts.windows.net/common/.well-known/openid-configuration',
    critical: true,
    category: 'auth'
  },
  {
    id: 'login-windows',
    name: 'login.windows.net',
    desc: 'Legacy Authentication Endpoint',
    url: 'https://login.windows.net/common/.well-known/openid-configuration',
    critical: false,
    category: 'auth'
  },
  {
    id: 'msauth-cdn',
    name: 'aadcdn.msauth.net',
    desc: 'MSAL Authentication Library CDN',
    url: 'https://aadcdn.msauth.net/',
    critical: false,
    category: 'cdn'
  },
  {
    id: 'msftauth-cdn',
    name: 'aadcdn.msftauth.net',
    desc: 'Microsoft Auth CDN',
    url: 'https://aadcdn.msftauth.net/',
    critical: false,
    category: 'cdn'
  },
  {
    id: 'management-azure',
    name: 'management.azure.com',
    desc: 'Azure Management API',
    url: 'https://management.azure.com/providers?api-version=2021-04-01',
    critical: false,
    category: 'api'
  },
  {
    id: 'adminconsent',
    name: 'Admin Consent Endpoint',
    desc: 'OAuth2 Admin Consent URL Pattern',
    url: 'https://login.microsoftonline.com/common/adminconsent',
    critical: true,
    category: 'oauth'
  },
  {
    id: 'token-endpoint',
    name: 'Token Endpoint',
    desc: 'OAuth2 Token Exchange',
    url: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
    critical: true,
    category: 'oauth'
  },
  {
    id: 'authorize-endpoint',
    name: 'Authorize Endpoint',
    desc: 'OAuth2 Authorization',
    url: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
    critical: true,
    category: 'oauth'
  }
];

// Utility functions
function log(msg, level = 'info') {
  const el = document.getElementById('rawLog');
  const time = new Date().toISOString().substr(11, 12);
  const cls = `log-${level}`;
  el.innerHTML += `<span class="log-time">[${time}]</span> <span class="${cls}">${msg}</span>\n`;
  el.scrollTop = el.scrollHeight;
}

function updateProgress(current, total, label) {
  document.getElementById('progressLabel').textContent = label;
  document.getElementById('progressCount').textContent = `${current}/${total}`;
  document.getElementById('progressFill').style.width = `${(current / total) * 100}%`;
}

function createTestSection(endpoint) {
  const html = `
    <div class="test-section" id="section-${endpoint.id}">
      <div class="section-header" onclick="toggleSection('${endpoint.id}')">
        <div class="section-title-area">
          <div class="status-icon status-pending" id="icon-${endpoint.id}">◦</div>
          <div class="section-title">
            <h3>${endpoint.name}</h3>
            <p>${endpoint.desc} ${endpoint.critical ? '· <span style="color: var(--accent-orange)">Critical</span>' : ''}</p>
          </div>
        </div>
        <div class="section-timing">
          <span id="timing-${endpoint.id}">—</span>
          <span class="chevron" id="chev-${endpoint.id}">▾</span>
        </div>
      </div>
      <div class="section-body" id="body-${endpoint.id}">
        <div id="details-${endpoint.id}"></div>
      </div>
    </div>`;
  document.getElementById('testSections').innerHTML += html;
}

function toggleSection(id) {
  const body = document.getElementById(`body-${id}`);
  const chev = document.getElementById(`chev-${id}`);
  body.classList.toggle('open');
  chev.classList.toggle('open');
}

function toggleRawLog() {
  document.getElementById('rawLog').classList.toggle('active');
}

function setStatus(id, status, symbol) {
  const icon = document.getElementById(`icon-${id}`);
  icon.className = `status-icon status-${status}`;
  icon.textContent = symbol;
}

function collectEnvironment() {
  const env = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    cookiesEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack,
    timestamp: new Date().toISOString(),
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    screenRes: `${screen.width}x${screen.height}`,
    windowSize: `${window.innerWidth}x${window.innerHeight}`,
    protocol: location.protocol,
    online: navigator.onLine,
    connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown',
    serviceWorker: 'serviceWorker' in navigator ? 'supported' : 'not supported',
    webRTC: 'RTCPeerConnection' in window ? 'supported' : 'not supported',
  };

  RESULTS.environment = env;

  const grid = document.getElementById('envGrid');
  grid.innerHTML = '';
  for (const [key, val] of Object.entries(env)) {
    const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
    grid.innerHTML += `<div class="env-item"><span class="key">${label}:</span><span class="val">${val}</span></div>`;
  }

  document.getElementById('envBar').classList.add('active');
  log(`Environment collected: ${env.userAgent}`, 'info');
}

// Attempt to detect public IP for comparison
async function detectPublicIP() {
  try {
    const resp = await fetch('https://httpbin.org/ip', { mode: 'cors' });
    if (resp.ok) {
      const data = await resp.json();
      RESULTS.environment.publicIP = data.origin;
      const grid = document.getElementById('envGrid');
      grid.innerHTML += `<div class="env-item"><span class="key">Public IP:</span><span class="val">${data.origin}</span></div>`;
      log(`Public IP detected: ${data.origin}`, 'pass');
    }
  } catch (e) {
    RESULTS.environment.publicIP = 'Could not detect (blocked)';
    log('Could not detect public IP — httpbin blocked', 'warn');
    const grid = document.getElementById('envGrid');
    grid.innerHTML += `<div class="env-item"><span class="key">Public IP:</span><span class="val">Blocked (external API inaccessible)</span></div>`;
  }
}

// DNS Resolution test via timing
async function testDNSResolution(hostname) {
  const start = performance.now();
  try {
    await fetch(`https://${hostname}/favicon.ico`, {
      mode: 'no-cors',
      cache: 'no-store',
      signal: AbortSignal.timeout(8000)
    });
  } catch (e) {
    // Even errors tell us DNS resolved if we got a network error vs timeout
  }
  return performance.now() - start;
}

function toggleProxyPanel() {
  document.getElementById('proxyBody').classList.toggle('open');
  document.getElementById('proxyChev').classList.toggle('open');
}

// Comprehensive proxy detection
async function detectProxyConfiguration() {
  const proxyStart = performance.now();
  const checks = [];
  RESULTS.proxyDetection = { checks: [], summary: 'unknown', detectedIndicators: 0, totalChecks: 0 };

  log('Running proxy detection...', 'info');

  // ═══════════════════════════════════════════════════════
  // CHECK 1: WPAD / PAC Auto-Discovery
  // Corporate networks commonly use WPAD to auto-configure proxies
  // ═══════════════════════════════════════════════════════
  try {
    log('  Checking WPAD/PAC auto-discovery...', 'info');
    const wpadUrls = [
      'http://wpad/wpad.dat',
      'http://wpad.' + location.hostname.split('.').slice(-2).join('.') + '/wpad.dat',
    ];

    let wpadFound = false;
    let wpadDetails = [];

    for (const wpadUrl of wpadUrls) {
      try {
        const resp = await fetch(wpadUrl, {
          mode: 'no-cors',
          cache: 'no-store',
          signal: AbortSignal.timeout(3000)
        });
        // no-cors returns opaque response, but if it doesn't throw, something answered
        wpadDetails.push(`${wpadUrl} — responded (type: ${resp.type})`);
        wpadFound = true;
      } catch (e) {
        wpadDetails.push(`${wpadUrl} — not reachable`);
      }
    }

    // Also try to detect via DNS by checking if "wpad" hostname resolves
    try {
      const wpadDirect = await fetch('http://wpad:80/', {
        mode: 'no-cors',
        cache: 'no-store',
        signal: AbortSignal.timeout(2000)
      });
      wpadDetails.push(`wpad hostname — resolved (type: ${wpadDirect.type})`);
      wpadFound = true;
    } catch (e) {
      wpadDetails.push('wpad hostname — not resolvable');
    }

    checks.push({
      name: 'WPAD / PAC Auto-Discovery',
      status: wpadFound ? 'detected' : 'clear',
      detail: wpadFound
        ? 'WPAD proxy auto-configuration detected. Corporate network likely uses automatic proxy configuration.\n' + wpadDetails.join('\n')
        : 'No WPAD auto-discovery found.\n' + wpadDetails.join('\n')
    });
    log(`  WPAD: ${wpadFound ? 'DETECTED' : 'not found'}`, wpadFound ? 'warn' : 'pass');
  } catch (e) {
    checks.push({ name: 'WPAD / PAC Auto-Discovery', status: 'info', detail: `Check inconclusive: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 2: WebRTC Local IP Detection
  // Reveals internal network IPs which indicate network topology
  // ═══════════════════════════════════════════════════════
  try {
    log('  Detecting local IPs via WebRTC...', 'info');
    const localIPs = await new Promise((resolve) => {
      const ips = new Set();
      const timeout = setTimeout(() => resolve([...ips]), 5000);

      try {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        pc.createDataChannel('');
        pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(() => {});

        pc.onicecandidate = (e) => {
          if (!e || !e.candidate || !e.candidate.candidate) {
            clearTimeout(timeout);
            pc.close();
            resolve([...ips]);
            return;
          }
          const parts = e.candidate.candidate.split(' ');
          const ip = parts[4];
          if (ip && !ip.includes(':') && ip !== '0.0.0.0') {
            ips.add(ip);
          }
          // Also capture mDNS candidates
          if (e.candidate.candidate.includes('.local')) {
            const mdns = e.candidate.candidate.match(/([a-f0-9-]+\.local)/);
            if (mdns) ips.add(mdns[1] + ' (mDNS obfuscated)');
          }
        };
      } catch (e) {
        clearTimeout(timeout);
        resolve([...ips]);
      }
    });

    const hasPrivateIP = localIPs.some(ip =>
      ip.startsWith('10.') ||
      ip.startsWith('172.16.') || ip.startsWith('172.17.') || ip.startsWith('172.18.') ||
      ip.startsWith('172.19.') || ip.startsWith('172.2') || ip.startsWith('172.30.') ||
      ip.startsWith('172.31.') ||
      ip.startsWith('192.168.') ||
      ip.includes('.local')
    );

    const ipDetail = localIPs.length > 0
      ? `Local IPs found: ${localIPs.join(', ')}\n${hasPrivateIP ? 'Private/RFC1918 address detected — machine is behind NAT (typical for corporate networks)' : 'Public-facing IP only'}`
      : 'No local IPs detected (WebRTC may be blocked or mDNS obfuscation active)';

    checks.push({
      name: 'WebRTC Local Network Detection',
      status: localIPs.length > 0 ? 'info' : 'info',
      detail: ipDetail
    });

    RESULTS.proxyDetection.localIPs = localIPs;
    log(`  WebRTC IPs: ${localIPs.length > 0 ? localIPs.join(', ') : 'none detected'}`, 'info');
  } catch (e) {
    checks.push({ name: 'WebRTC Local Network Detection', status: 'info', detail: `WebRTC not available: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 3: Multiple IP Service Cross-Reference
  // If different services see different IPs, proxy is present
  // ═══════════════════════════════════════════════════════
  try {
    log('  Cross-referencing public IP via multiple services...', 'info');
    const ipServices = [
      { name: 'httpbin.org', url: 'https://httpbin.org/ip', extract: (d) => d.origin },
      { name: 'ipify.org', url: 'https://api.ipify.org?format=json', extract: (d) => d.ip },
      { name: 'icanhazip', url: 'https://icanhazip.com', extract: (d) => d.trim(), isText: true },
    ];

    const detectedIPs = [];

    for (const svc of ipServices) {
      try {
        const resp = await fetch(svc.url, { cache: 'no-store', signal: AbortSignal.timeout(5000) });
        if (resp.ok) {
          const data = svc.isText ? await resp.text() : await resp.json();
          const ip = svc.extract(data);
          detectedIPs.push({ service: svc.name, ip });
        }
      } catch (e) {
        detectedIPs.push({ service: svc.name, ip: `Error: ${e.message}` });
      }
    }

    const validIPs = detectedIPs.filter(d => !d.ip.startsWith('Error')).map(d => d.ip);
    const uniqueIPs = [...new Set(validIPs)];
    const mismatch = uniqueIPs.length > 1;

    let detail = detectedIPs.map(d => `${d.service}: ${d.ip}`).join('\n');
    if (mismatch) {
      detail += '\n⚠ DIFFERENT IPs from different services — traffic may be routed through different proxies';
    } else if (uniqueIPs.length === 1) {
      detail += '\nAll services report same IP — consistent egress path';
    }

    checks.push({
      name: 'Public IP Cross-Reference',
      status: mismatch ? 'detected' : (validIPs.length > 0 ? 'clear' : 'error'),
      detail: detail
    });

    RESULTS.proxyDetection.publicIPs = detectedIPs;
    log(`  IP cross-ref: ${uniqueIPs.join(', ') || 'no IPs detected'}${mismatch ? ' — MISMATCH!' : ''}`, mismatch ? 'warn' : 'pass');
  } catch (e) {
    checks.push({ name: 'Public IP Cross-Reference', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 4: Proxy Headers in Microsoft Responses
  // Aggregate proxy headers found across all already-tested endpoints
  // ═══════════════════════════════════════════════════════
  try {
    log('  Analyzing response headers for proxy signatures...', 'info');
    const proxyHeaderNames = [
      'via', 'x-forwarded-for', 'x-forwarded-host', 'x-forwarded-proto',
      'x-real-ip', 'x-cache', 'x-cache-hit', 'x-cache-lookup',
      'front-end-https', 'x-proxy-id', 'x-authenticated-user'
    ];
    const proxyVendorPatterns = [
      'bluecoat', 'zscaler', 'squid', 'fortinet', 'fortigate',
      'palo-alto', 'barracuda', 'sophos', 'websense', 'netskope',
      'mcafee', 'symantec', 'cisco', 'checkpoint'
    ];

    const foundHeaders = [];

    for (const t of RESULTS.tests) {
      for (const [k, v] of Object.entries(t.headers || {})) {
        const kl = k.toLowerCase();
        if (proxyHeaderNames.includes(kl) || proxyVendorPatterns.some(p => kl.includes(p))) {
          foundHeaders.push({ endpoint: t.name, header: k, value: v });
        }
      }
    }

    if (foundHeaders.length > 0) {
      const detail = foundHeaders.map(h => `${h.endpoint} → ${h.header}: ${h.value}`).join('\n');
      checks.push({
        name: 'Proxy Headers in Responses',
        status: 'detected',
        detail: `${foundHeaders.length} proxy header(s) found across endpoint responses:\n${detail}`
      });
      log(`  Proxy headers: ${foundHeaders.length} found`, 'warn');
    } else {
      checks.push({
        name: 'Proxy Headers in Responses',
        status: 'clear',
        detail: 'No proxy-specific headers (Via, X-Forwarded-For, vendor headers) detected in any Microsoft endpoint responses.'
      });
      log('  Proxy headers: none found', 'pass');
    }
  } catch (e) {
    checks.push({ name: 'Proxy Headers in Responses', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 5: Timing Differential Analysis
  // Proxies add consistent overhead — compare direct IP vs hostname
  // ═══════════════════════════════════════════════════════
  try {
    log('  Running timing differential analysis...', 'info');

    // Test: Fetch same logical endpoint multiple times and analyze jitter
    const timingSamples = [];
    for (let i = 0; i < 5; i++) {
      const s = performance.now();
      try {
        await fetch('https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration', {
          cache: 'no-store',
          signal: AbortSignal.timeout(8000)
        });
      } catch (e) {}
      timingSamples.push(Math.round(performance.now() - s));
    }

    const avg = Math.round(timingSamples.reduce((a, b) => a + b) / timingSamples.length);
    const min = Math.min(...timingSamples);
    const max = Math.max(...timingSamples);
    const jitter = max - min;

    // Also test a non-Microsoft endpoint for comparison
    const extSamples = [];
    for (let i = 0; i < 3; i++) {
      const s = performance.now();
      try {
        await fetch('https://httpbin.org/status/200', {
          cache: 'no-store',
          mode: 'no-cors',
          signal: AbortSignal.timeout(8000)
        });
      } catch (e) {}
      extSamples.push(Math.round(performance.now() - s));
    }
    const extAvg = extSamples.length > 0 ? Math.round(extSamples.reduce((a, b) => a + b) / extSamples.length) : 0;

    const highLatency = avg > 1500;
    const highJitter = jitter > 1000;
    const suspiciousDelta = Math.abs(avg - extAvg) > 500;

    let detail = `Microsoft auth endpoint (5 samples):\n  Samples: ${timingSamples.join('ms, ')}ms\n  Avg: ${avg}ms | Min: ${min}ms | Max: ${max}ms | Jitter: ${jitter}ms\n`;
    detail += `\nExternal endpoint (3 samples):\n  Samples: ${extSamples.join('ms, ')}ms\n  Avg: ${extAvg}ms\n`;
    detail += `\nDelta: ${Math.abs(avg - extAvg)}ms`;

    if (highLatency) detail += '\n⚠ High average latency — possible SSL inspection or proxy overhead';
    if (highJitter) detail += '\n⚠ High jitter — inconsistent network path or proxy queueing';
    if (suspiciousDelta) detail += '\n⚠ Large difference between Microsoft and external endpoints — selective proxy routing possible';

    checks.push({
      name: 'Timing Differential Analysis',
      status: (highLatency || highJitter || suspiciousDelta) ? 'detected' : 'clear',
      detail: detail
    });

    RESULTS.proxyDetection.timingAnalysis = { msAuth: timingSamples, external: extSamples, avg, extAvg, jitter };
    log(`  Timing: MS avg ${avg}ms, ext avg ${extAvg}ms, jitter ${jitter}ms`, (highLatency || highJitter) ? 'warn' : 'pass');
  } catch (e) {
    checks.push({ name: 'Timing Differential Analysis', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 6: Resource Timing / Performance API
  // Can reveal proxy negotiation in connection stages
  // ═══════════════════════════════════════════════════════
  try {
    log('  Analyzing Performance Resource Timing...', 'info');
    // Clear existing entries and make a fresh request
    performance.clearResourceTimings();

    await fetch('https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration', {
      cache: 'no-store',
      signal: AbortSignal.timeout(8000)
    });

    const entries = performance.getEntriesByType('resource').filter(e =>
      e.name.includes('login.microsoftonline.com')
    );

    if (entries.length > 0) {
      const entry = entries[entries.length - 1];
      const breakdown = {
        dns: Math.round(entry.domainLookupEnd - entry.domainLookupStart),
        tcp: Math.round(entry.connectEnd - entry.connectStart),
        ssl: Math.round(entry.connectEnd - entry.secureConnectionStart),
        ttfb: Math.round(entry.responseStart - entry.requestStart),
        download: Math.round(entry.responseEnd - entry.responseStart),
        total: Math.round(entry.responseEnd - entry.startTime),
        redirects: Math.round(entry.redirectEnd - entry.redirectStart),
        // These can indicate proxy
        workerStart: Math.round(entry.workerStart || 0),
        nextHopProtocol: entry.nextHopProtocol || 'unknown',
        transferSize: entry.transferSize,
        encodedBodySize: entry.encodedBodySize,
        decodedBodySize: entry.decodedBodySize,
      };

      const slowTCP = breakdown.tcp > 500;
      const slowSSL = breakdown.ssl > 1000;
      const slowTTFB = breakdown.ttfb > 1000;
      const hasRedirects = breakdown.redirects > 0;

      let detail = `Resource Timing for login.microsoftonline.com:\n`;
      detail += `  DNS Lookup:     ${breakdown.dns}ms ${breakdown.dns === 0 ? '(cached)' : ''}\n`;
      detail += `  TCP Connect:    ${breakdown.tcp}ms ${slowTCP ? '⚠ SLOW' : ''}\n`;
      detail += `  SSL/TLS:        ${breakdown.ssl}ms ${slowSSL ? '⚠ SLOW — possible SSL interception' : ''}\n`;
      detail += `  TTFB:           ${breakdown.ttfb}ms ${slowTTFB ? '⚠ SLOW' : ''}\n`;
      detail += `  Download:       ${breakdown.download}ms\n`;
      detail += `  Total:          ${breakdown.total}ms\n`;
      detail += `  Redirects:      ${breakdown.redirects}ms ${hasRedirects ? '⚠ unexpected redirect stage' : ''}\n`;
      detail += `  Protocol:       ${breakdown.nextHopProtocol}\n`;
      detail += `  Transfer Size:  ${breakdown.transferSize} bytes\n`;
      detail += `  Encoded Body:   ${breakdown.encodedBodySize} bytes\n`;
      detail += `  Decoded Body:   ${breakdown.decodedBodySize} bytes`;

      if (breakdown.transferSize > 0 && breakdown.encodedBodySize > 0 &&
          breakdown.transferSize - breakdown.encodedBodySize > 500) {
        detail += '\n⚠ Large header overhead (transfer vs body) — possible proxy injection of headers';
      }

      checks.push({
        name: 'Performance Resource Timing',
        status: (slowSSL || slowTCP || hasRedirects) ? 'detected' : 'clear',
        detail: detail
      });

      RESULTS.proxyDetection.resourceTiming = breakdown;
      log(`  Resource timing: DNS ${breakdown.dns}ms, TCP ${breakdown.tcp}ms, SSL ${breakdown.ssl}ms, TTFB ${breakdown.ttfb}ms`, (slowSSL || slowTCP) ? 'warn' : 'pass');
    } else {
      checks.push({
        name: 'Performance Resource Timing',
        status: 'info',
        detail: 'No resource timing entries available (cross-origin timing may be restricted by Timing-Allow-Origin header)'
      });
      log('  Resource timing: no entries available', 'info');
    }
  } catch (e) {
    checks.push({ name: 'Performance Resource Timing', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 7: HTTP/2 vs HTTP/1.1 Protocol Detection
  // Proxies often downgrade HTTP/2 to HTTP/1.1
  // ═══════════════════════════════════════════════════════
  try {
    log('  Checking HTTP protocol negotiation...', 'info');
    const protoEntries = performance.getEntriesByType('resource').filter(e =>
      e.name.includes('login.microsoftonline.com') || e.name.includes('graph.microsoft.com')
    );

    const protocols = {};
    protoEntries.forEach(e => {
      const host = new URL(e.name).hostname;
      if (e.nextHopProtocol) {
        protocols[host] = e.nextHopProtocol;
      }
    });

    const protoList = Object.entries(protocols);
    if (protoList.length > 0) {
      const hasHTTP1 = protoList.some(([_, p]) => p === 'http/1.1' || p === 'http/1.0');
      let detail = protoList.map(([h, p]) => `${h}: ${p}`).join('\n');

      if (hasHTTP1) {
        detail += '\n\n⚠ HTTP/1.1 detected — Microsoft endpoints normally negotiate HTTP/2 (h2). HTTP/1.1 strongly suggests a proxy or firewall is intercepting and downgrading the connection.';
      } else {
        detail += '\n\nHTTP/2 (h2) negotiated as expected — no protocol downgrade detected.';
      }

      checks.push({
        name: 'HTTP Protocol Negotiation',
        status: hasHTTP1 ? 'detected' : 'clear',
        detail: detail
      });
      log(`  Protocol: ${protoList.map(([h, p]) => `${h}=${p}`).join(', ')}`, hasHTTP1 ? 'warn' : 'pass');
    } else {
      checks.push({
        name: 'HTTP Protocol Negotiation',
        status: 'info',
        detail: 'Protocol data not available from Performance API.'
      });
    }
  } catch (e) {
    checks.push({ name: 'HTTP Protocol Negotiation', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 8: Response Body Size Validation
  // Proxies sometimes inject content or replace responses
  // ═══════════════════════════════════════════════════════
  try {
    log('  Validating response body integrity...', 'info');
    const resp = await fetch('https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration', {
      cache: 'no-store',
      signal: AbortSignal.timeout(8000)
    });
    const body = await resp.text();

    // Validate it's proper OpenID config
    let isValid = false;
    let issues = [];
    try {
      const json = JSON.parse(body);
      if (json.token_endpoint && json.authorization_endpoint && json.issuer) {
        isValid = true;
        if (!json.token_endpoint.includes('login.microsoftonline.com') &&
            !json.token_endpoint.includes('login.microsoft.com')) {
          issues.push(`Token endpoint points to unexpected domain: ${json.token_endpoint}`);
        }
        if (!json.issuer.includes('sts.windows.net') && !json.issuer.includes('login.microsoftonline.com')) {
          issues.push(`Issuer is unexpected: ${json.issuer}`);
        }
      } else {
        issues.push('Response missing required OpenID fields (token_endpoint, authorization_endpoint, issuer)');
      }
    } catch (e) {
      issues.push(`Response is not valid JSON: ${e.message}`);
      issues.push(`Body starts with: ${body.substring(0, 200)}`);
    }

    // Check for injected content
    if (body.includes('<script') || body.includes('<html') || body.includes('<iframe')) {
      issues.push('Response contains HTML/script tags — proxy may be injecting content');
    }

    checks.push({
      name: 'Response Body Integrity',
      status: issues.length > 0 ? 'detected' : 'clear',
      detail: isValid && issues.length === 0
        ? 'OpenID Configuration response is valid and unmodified. Token endpoint and issuer match expected Microsoft domains.'
        : `Integrity issues found:\n${issues.join('\n')}`
    });
    log(`  Body integrity: ${issues.length === 0 ? 'valid' : issues.length + ' issues'}`, issues.length > 0 ? 'warn' : 'pass');
  } catch (e) {
    checks.push({ name: 'Response Body Integrity', status: 'error', detail: `Check failed: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // CHECK 9: Browser Proxy Configuration (navigator hints)
  // ═══════════════════════════════════════════════════════
  try {
    log('  Checking browser/OS proxy hints...', 'info');
    let detail = '';
    const hints = [];

    // Check connection info
    if (navigator.connection) {
      const c = navigator.connection;
      hints.push(`Connection type: ${c.effectiveType || 'unknown'}`);
      hints.push(`Downlink: ${c.downlink || 'unknown'} Mbps`);
      hints.push(`RTT: ${c.rtt || 'unknown'}ms`);
      if (c.rtt > 300) hints.push('⚠ High RTT may indicate proxy routing');
    }

    // Check if running in controlled environment
    if (navigator.managed !== undefined) {
      hints.push(`Managed browser: ${navigator.managed ? 'YES — enterprise managed' : 'no'}`);
    }

    // Check for Enterprise policies via chrome
    if (window.chrome && window.chrome.runtime) {
      hints.push('Chrome Enterprise runtime detected');
    }

    // Check if Brave or privacy browser (may have built-in proxy)
    if (navigator.brave) {
      hints.push('Brave browser detected (built-in privacy proxy possible)');
    }

    detail = hints.length > 0 ? hints.join('\n') : 'No additional browser proxy hints available.';

    checks.push({
      name: 'Browser & OS Network Hints',
      status: 'info',
      detail: detail
    });
  } catch (e) {
    checks.push({ name: 'Browser & OS Network Hints', status: 'info', detail: `Limited info: ${e.message}` });
  }

  // ═══════════════════════════════════════════════════════
  // COMPILE RESULTS
  // ═══════════════════════════════════════════════════════
  const proxyElapsed = Math.round(performance.now() - proxyStart);
  const detectedCount = checks.filter(c => c.status === 'detected').length;
  const clearCount = checks.filter(c => c.status === 'clear').length;

  RESULTS.proxyDetection.checks = checks;
  RESULTS.proxyDetection.totalChecks = checks.length;
  RESULTS.proxyDetection.detectedIndicators = detectedCount;
  RESULTS.proxyDetection.timing = proxyElapsed;

  let overallStatus;
  if (detectedCount >= 3) {
    overallStatus = 'detected';
    RESULTS.proxyDetection.summary = 'PROXY LIKELY — Multiple indicators detected';
  } else if (detectedCount >= 1) {
    overallStatus = 'detected';
    RESULTS.proxyDetection.summary = 'PROXY POSSIBLE — Some indicators detected';
  } else {
    overallStatus = 'clear';
    RESULTS.proxyDetection.summary = 'NO PROXY DETECTED — All checks clear';
  }

  // Update UI
  const panel = document.getElementById('proxyPanel');
  panel.classList.add('active');
  panel.classList.add(overallStatus === 'detected' ? 'proxy-detected' : 'proxy-clear');

  const icon = document.getElementById('proxyStatusIcon');
  if (overallStatus === 'detected') {
    icon.className = 'status-icon status-warn';
    icon.textContent = '!';
  } else {
    icon.className = 'status-icon status-pass';
    icon.textContent = '✓';
  }

  document.getElementById('proxyTiming').textContent = `${detectedCount}/${checks.length} indicators · ${proxyElapsed}ms`;

  // Render checks
  const container = document.getElementById('proxyChecks');
  container.innerHTML = '';
  for (const check of checks) {
    const iconCls = check.status === 'detected' ? 'pci-detected' :
                    check.status === 'clear' ? 'pci-clear' :
                    check.status === 'error' ? 'pci-error' : 'pci-info';
    const iconSymbol = check.status === 'detected' ? '!' :
                       check.status === 'clear' ? '✓' :
                       check.status === 'error' ? '✕' : 'ℹ';

    container.innerHTML += `
      <div class="proxy-check-row">
        <div class="proxy-check-icon ${iconCls}">${iconSymbol}</div>
        <div class="proxy-check-content">
          <div class="proxy-check-name">${escHtml(check.name)} <span class="tag tag-${check.status === 'detected' ? 'warn' : check.status === 'clear' ? 'pass' : check.status === 'error' ? 'fail' : 'info'}">${check.status}</span></div>
          <div class="proxy-check-detail">${escHtml(check.detail)}</div>
        </div>
      </div>`;
  }

  // Auto-expand if proxy detected
  if (detectedCount > 0) {
    document.getElementById('proxyBody').classList.add('open');
    document.getElementById('proxyChev').classList.add('open');
  }

  log(`Proxy detection complete: ${detectedCount}/${checks.length} indicators, ${proxyElapsed}ms`, detectedCount > 0 ? 'warn' : 'pass');
  return RESULTS.proxyDetection;
}


  const start = performance.now();
  try {
    // We use an image load trick to test DNS separately
    await fetch(`https://${hostname}/favicon.ico`, {
      mode: 'no-cors',
      cache: 'no-store',
      signal: AbortSignal.timeout(8000)
    });
  } catch (e) {
    // Even errors tell us DNS resolved if we got a network error vs timeout
  }
  return performance.now() - start;
}

// Main endpoint test
async function testEndpoint(endpoint) {
  const testResult = {
    id: endpoint.id,
    name: endpoint.name,
    url: endpoint.url,
    critical: endpoint.critical,
    category: endpoint.category,
    status: 'pending',
    timing: null,
    httpStatus: null,
    httpStatusText: null,
    headers: {},
    corsHeaders: {},
    redirected: false,
    redirectURL: null,
    error: null,
    sslIssues: [],
    proxyIndicators: [],
    details: {},
    raw: {
      request: {
        method: 'GET',
        url: endpoint.url,
        headers: {
          'Accept': 'application/json, text/html, */*',
          'X-Diagnostic-Request': 'azure-oauth-diag-v1',
          'Cache-Control': 'no-store',
          'Sec-Fetch-Mode': 'cors'
        },
        mode: 'cors',
        redirect: 'follow',
        cache: 'no-store',
        timestamp: new Date().toISOString()
      },
      response: {
        status: null,
        statusText: null,
        headers: {},
        headersRaw: '',
        body: null,
        bodyTruncated: false,
        bodyLength: 0,
        type: null,
        url: null,
        redirected: false,
        ok: null,
        timestamp: null
      },
      noCors: null,
      error: null,
      timings: {
        start: null,
        headersReceived: null,
        bodyReceived: null,
        total: null
      }
    }
  };

  setStatus(endpoint.id, 'running', '●');
  log(`Testing: ${endpoint.url}`, 'info');

  const start = performance.now();
  testResult.raw.timings.start = new Date().toISOString();

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 15000);

    const response = await fetch(endpoint.url, {
      method: 'GET',
      mode: 'cors',
      cache: 'no-store',
      redirect: 'follow',
      signal: controller.signal,
      headers: {
        'Accept': 'application/json, text/html, */*',
        'X-Diagnostic-Request': 'azure-oauth-diag-v1'
      }
    });

    clearTimeout(timeout);
    const headersTime = performance.now();
    testResult.raw.timings.headersReceived = Math.round(headersTime - start);

    const elapsed = headersTime - start;
    testResult.timing = Math.round(elapsed);
    testResult.httpStatus = response.status;
    testResult.httpStatusText = response.statusText;
    testResult.redirected = response.redirected;
    testResult.redirectURL = response.redirected ? response.url : null;

    // Capture raw response metadata
    testResult.raw.response.status = response.status;
    testResult.raw.response.statusText = response.statusText;
    testResult.raw.response.type = response.type;
    testResult.raw.response.url = response.url;
    testResult.raw.response.redirected = response.redirected;
    testResult.raw.response.ok = response.ok;

    // Capture all response headers (both structured and raw string)
    let headersRaw = '';
    response.headers.forEach((value, key) => {
      testResult.headers[key] = value;
      testResult.raw.response.headers[key] = value;
      headersRaw += `${key}: ${value}\n`;

      const kl = key.toLowerCase();
      // Check for proxy indicators — EXCLUDE standard Microsoft x-ms-* headers
      const isProxyHeader = (
        kl === 'via' ||
        kl === 'x-forwarded-for' ||
        kl === 'x-forwarded-host' ||
        kl === 'x-forwarded-proto' ||
        kl === 'x-real-ip' ||
        kl === 'x-cache' ||
        kl === 'x-cache-hit' ||
        kl === 'x-cache-lookup' ||
        kl.includes('x-bluecoat') ||
        kl.includes('x-zscaler') ||
        kl.includes('x-squid') ||
        kl.includes('x-fortinet') ||
        kl.includes('x-fortigate') ||
        kl.includes('x-palo-alto') ||
        kl.includes('x-barracuda') ||
        kl.includes('x-sophos') ||
        kl.includes('x-websense') ||
        kl.includes('x-netskope') ||
        kl.includes('x-mcafee') ||
        kl.includes('x-symantec') ||
        kl === 'front-end-https' ||
        kl === 'x-proxy-id' ||
        kl === 'x-authenticated-user' ||
        (kl.startsWith('x-') && kl.includes('proxy')) ||
        (kl.startsWith('x-') && kl.includes('firewall'))
      );
      if (isProxyHeader) {
        testResult.proxyIndicators.push({ header: key, value: value });
      }
      // Check for CORS
      if (kl.startsWith('access-control')) {
        testResult.corsHeaders[key] = value;
      }
    });
    testResult.raw.response.headersRaw = headersRaw;

    // Try to read body for additional info
    try {
      const text = await response.text();
      const bodyTime = performance.now();
      testResult.raw.timings.bodyReceived = Math.round(bodyTime - start);
      testResult.raw.timings.total = Math.round(bodyTime - start);
      testResult.raw.response.timestamp = new Date().toISOString();

      testResult.details.bodyLength = text.length;
      testResult.details.bodyPreview = text.substring(0, 500);

      // Store full body (cap at 200KB for memory, truncate larger)
      const MAX_RAW_BODY = 200000;
      if (text.length <= MAX_RAW_BODY) {
        testResult.raw.response.body = text;
        testResult.raw.response.bodyTruncated = false;
      } else {
        testResult.raw.response.body = text.substring(0, MAX_RAW_BODY);
        testResult.raw.response.bodyTruncated = true;
      }
      testResult.raw.response.bodyLength = text.length;

      // Check if body contains proxy/firewall block pages
      // Only flag if body is small (block pages are typically <50KB) AND contains block indicators
      // Large bodies (like Graph $metadata) are legitimate responses, not block pages
      const lower = text.toLowerCase();
      const isSmallBody = text.length < 50000;
      const isNotXmlMetadata = !lower.startsWith('<?xml') || !lower.includes('edmx:edmx');
      const isNotJsonConfig = !lower.startsWith('{') || !(lower.includes('token_endpoint') || lower.includes('authorization_endpoint'));

      if (isSmallBody && isNotXmlMetadata && isNotJsonConfig) {
        const blockPagePatterns = [
          /access\s+(denied|blocked|forbidden)/i,
          /this\s+site\s+(is\s+)?blocked/i,
          /web\s+filter/i,
          /content\s+filtering/i,
          /firewall\s+(has\s+)?blocked/i,
          /request\s+(was\s+)?(blocked|denied)/i,
          /security\s+policy\s+(violation|block)/i,
          /websense/i,
          /fortigate/i,
          /fortiguard/i,
          /palo\s*alto/i,
          /bluecoat/i,
          /zscaler/i,
          /sophos\s+utm/i,
          /barracuda/i,
          /cisco\s+umbrella/i,
          /url\s+categorization/i,
          /this\s+page\s+has\s+been\s+blocked/i,
          /your\s+(organization|administrator)\s+(has\s+)?(blocked|restricted)/i
        ];
        const matched = blockPagePatterns.filter(p => p.test(text));
        if (matched.length > 0) {
          testResult.sslIssues.push('Response body contains firewall/proxy block page indicators');
          testResult.proxyIndicators.push({ header: 'body-content', value: `Block page detected (${matched.length} pattern matches)` });
        }
      }
    } catch (bodyErr) {
      testResult.details.bodyError = bodyErr.message;
    }

    // Determine status
    if (response.status >= 200 && response.status < 400) {
      testResult.status = 'pass';
      if (testResult.proxyIndicators.length > 0) {
        testResult.status = 'warn';
      }
    } else if (response.status === 401 || response.status === 403) {
      // Expected for endpoints that require auth tokens - this proves the endpoint is reachable
      testResult.status = 'pass';
      testResult.details.note = 'Auth error (401/403) is expected for unauthenticated diagnostic requests — confirms endpoint is reachable';
    } else if (response.status === 400) {
      // Bad request can be expected when hitting endpoints without proper parameters
      testResult.status = 'pass';
      testResult.details.note = 'Bad request (400) is expected when hitting endpoints without required parameters — confirms endpoint is reachable';
    } else {
      testResult.status = 'fail';
    }

    // Check timing anomalies (SSL inspection adds latency)
    if (elapsed > 5000) {
      testResult.sslIssues.push(`High latency (${Math.round(elapsed)}ms) — possible SSL inspection delay`);
      if (testResult.status === 'pass') testResult.status = 'warn';
    }

  } catch (error) {
    const elapsed = performance.now() - start;
    testResult.timing = Math.round(elapsed);
    testResult.raw.timings.total = Math.round(elapsed);
    testResult.error = error.message || error.toString();
    testResult.raw.error = {
      name: error.name,
      message: error.message,
      stack: error.stack ? error.stack.substring(0, 1000) : null,
      timestamp: new Date().toISOString()
    };

    if (error.name === 'AbortError') {
      testResult.status = 'fail';
      testResult.error = 'Request timed out (15s) — endpoint likely blocked';
      log(`TIMEOUT: ${endpoint.url}`, 'fail');
    } else if (error.message && error.message.includes('Failed to fetch')) {
      testResult.status = 'fail';
      testResult.error = 'Failed to fetch — CORS blocked, network error, or endpoint unreachable';
      log(`BLOCKED: ${endpoint.url} — ${error.message}`, 'fail');
    } else {
      testResult.status = 'fail';
      log(`ERROR: ${endpoint.url} — ${error.message}`, 'fail');
    }
  }

  // Now run additional no-cors test if main test failed
  if (testResult.status === 'fail') {
    try {
      const start2 = performance.now();
      const noCorsResp = await fetch(endpoint.url, { mode: 'no-cors', cache: 'no-store', signal: AbortSignal.timeout(10000) });
      const elapsed2 = performance.now() - start2;
      testResult.details.noCorsReachable = true;
      testResult.details.noCorsTime = Math.round(elapsed2);
      testResult.status = 'pass';
      testResult.details.note = `Endpoint reachable (${Math.round(elapsed2)}ms). CORS restriction is normal — this endpoint is designed for server-side or redirect-based access, not direct browser calls.`;
      testResult.raw.noCors = {
        reachable: true,
        timing: Math.round(elapsed2),
        type: noCorsResp.type,
        status: noCorsResp.status,
        url: noCorsResp.url,
        timestamp: new Date().toISOString(),
        note: 'no-cors mode: browser blocks reading response details but confirms network reachability'
      };
      log(`  ↳ no-cors reachable for ${endpoint.name} (${Math.round(elapsed2)}ms) — CORS restriction is expected`, 'pass');
    } catch (e2) {
      testResult.details.noCorsReachable = false;
      testResult.details.noCorsError = e2.message;
      testResult.raw.noCors = {
        reachable: false,
        error: e2.message,
        errorName: e2.name,
        timestamp: new Date().toISOString()
      };
      log(`  ↳ no-cors also failed for ${endpoint.name}: ${e2.message}`, 'fail');
    }
  }

  // Update UI
  const statusSymbol = testResult.status === 'pass' ? '✓' : testResult.status === 'warn' ? '!' : '✕';
  setStatus(endpoint.id, testResult.status, statusSymbol);
  document.getElementById(`timing-${endpoint.id}`).textContent = `${testResult.timing}ms`;

  const sectionEl = document.getElementById(`section-${endpoint.id}`);
  sectionEl.classList.add(`result-${testResult.status}`);

  // Build detail HTML
  renderTestDetails(endpoint.id, testResult);

  log(`Result: ${endpoint.name} → ${testResult.status.toUpperCase()} (${testResult.timing}ms, HTTP ${testResult.httpStatus || 'N/A'})`, testResult.status === 'pass' ? 'pass' : testResult.status === 'warn' ? 'warn' : 'fail');

  return testResult;
}

function escHtml(str) {
  if (str == null) return '';
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function formatRawRequest(raw) {
  const r = raw.request;
  let out = '';
  out += `<span class="http-method">${r.method}</span> <span class="http-url">${escHtml(r.url)}</span> <span class="http-version">HTTP/1.1</span>\n`;
  // Extract hostname for Host header
  try {
    const host = new URL(r.url).host;
    out += `<span class="header-name">Host:</span> <span class="header-value">${escHtml(host)}</span>\n`;
  } catch(e) {}
  for (const [k, v] of Object.entries(r.headers)) {
    out += `<span class="header-name">${escHtml(k)}:</span> <span class="header-value">${escHtml(v)}</span>\n`;
  }
  out += `<span class="header-name">Mode:</span> <span class="header-value">${r.mode}</span>\n`;
  out += `<span class="header-name">Redirect:</span> <span class="header-value">${r.redirect}</span>\n`;
  out += `<span class="header-name">Cache:</span> <span class="header-value">${r.cache}</span>\n`;
  out += `\n<span class="body-separator">--- Timestamp: ${r.timestamp} ---</span>`;
  return out;
}

function formatRawResponse(raw) {
  const r = raw.response;
  let out = '';

  if (r.status !== null) {
    const statusCls = r.status >= 200 && r.status < 300 ? 'http-status-ok' :
                      r.status >= 300 && r.status < 400 ? 'http-status-warn' : 'http-status-err';
    out += `<span class="http-version">HTTP/1.1</span> <span class="${statusCls}">${r.status} ${escHtml(r.statusText || '')}</span>\n`;
    out += `<span class="header-name">Response-Type:</span> <span class="header-value">${r.type || 'N/A'}</span>\n`;
    out += `<span class="header-name">Response-URL:</span> <span class="header-value">${escHtml(r.url || 'N/A')}</span>\n`;
    out += `<span class="header-name">Redirected:</span> <span class="header-value">${r.redirected}</span>\n`;
    out += `<span class="header-name">OK:</span> <span class="header-value">${r.ok}</span>\n`;

    // Headers
    for (const [k, v] of Object.entries(r.headers)) {
      out += `<span class="header-name">${escHtml(k)}:</span> <span class="header-value">${escHtml(v)}</span>\n`;
    }

    // Body
    out += `\n<span class="body-separator">--- Response Body (${r.bodyLength ? r.bodyLength.toLocaleString() + ' bytes' : 'empty'}) ---</span>\n`;
    if (r.body) {
      // Try to pretty-print JSON
      let bodyDisplay = r.body;
      if (r.body.trim().startsWith('{') || r.body.trim().startsWith('[')) {
        try {
          bodyDisplay = JSON.stringify(JSON.parse(r.body), null, 2);
        } catch(e) { /* not valid JSON, show raw */ }
      }
      out += `<span class="body-content">${escHtml(bodyDisplay)}</span>`;
      if (r.bodyTruncated) {
        out += `\n<span class="body-truncated">... [TRUNCATED — original ${r.bodyLength.toLocaleString()} bytes, showing first 200KB] ...</span>`;
      }
    } else {
      out += `<span class="body-content">[No body captured — CORS or network error prevented reading]</span>`;
    }
  } else {
    // No response — show error
    out += `<span class="http-status-err">NO RESPONSE RECEIVED</span>\n`;
    if (raw.error) {
      out += `<span class="header-name">Error-Name:</span> <span class="header-value">${escHtml(raw.error.name)}</span>\n`;
      out += `<span class="header-name">Error-Message:</span> <span class="header-value">${escHtml(raw.error.message)}</span>\n`;
      if (raw.error.stack) {
        out += `\n<span class="body-separator">--- Stack Trace ---</span>\n`;
        out += `<span class="body-content">${escHtml(raw.error.stack)}</span>`;
      }
    }
  }

  // Timing info
  const t = raw.timings;
  out += `\n\n<span class="body-separator">--- Timing ---</span>\n`;
  out += `<span class="header-name">Start:</span> <span class="header-value">${t.start || 'N/A'}</span>\n`;
  out += `<span class="header-name">Headers-Received:</span> <span class="header-value">${t.headersReceived != null ? t.headersReceived + 'ms' : 'N/A'}</span>\n`;
  out += `<span class="header-name">Body-Received:</span> <span class="header-value">${t.bodyReceived != null ? t.bodyReceived + 'ms' : 'N/A'}</span>\n`;
  out += `<span class="header-name">Total:</span> <span class="header-value">${t.total != null ? t.total + 'ms' : 'N/A'}</span>\n`;
  if (r.timestamp) {
    out += `<span class="header-name">End:</span> <span class="header-value">${r.timestamp}</span>`;
  }

  return out;
}

function formatRawNoCors(noCors) {
  if (!noCors) return '';
  let out = '';
  if (noCors.reachable) {
    out += `<span class="http-status-ok">REACHABLE via no-cors</span>\n`;
    out += `<span class="header-name">Response-Type:</span> <span class="header-value">${noCors.type || 'opaque'}</span>\n`;
    out += `<span class="header-name">Status:</span> <span class="header-value">${noCors.status} (opaque — actual status hidden by browser)</span>\n`;
    out += `<span class="header-name">URL:</span> <span class="header-value">${escHtml(noCors.url || 'N/A')}</span>\n`;
    out += `<span class="header-name">Timing:</span> <span class="header-value">${noCors.timing}ms</span>\n`;
    out += `<span class="header-name">Timestamp:</span> <span class="header-value">${noCors.timestamp}</span>\n`;
    out += `\n<span class="body-separator">--- Note ---</span>\n`;
    out += `<span class="body-content">${escHtml(noCors.note)}</span>`;
  } else {
    out += `<span class="http-status-err">NOT REACHABLE (no-cors also failed)</span>\n`;
    out += `<span class="header-name">Error:</span> <span class="header-value">${escHtml(noCors.error)}</span>\n`;
    out += `<span class="header-name">Error-Name:</span> <span class="header-value">${escHtml(noCors.errorName)}</span>\n`;
    out += `<span class="header-name">Timestamp:</span> <span class="header-value">${noCors.timestamp}</span>`;
  }
  return out;
}

function getRawPlainText(raw) {
  // Generate plain text version for copy-to-clipboard
  let out = '';
  const r = raw.request;
  out += `=== REQUEST ===\n`;
  out += `${r.method} ${r.url} HTTP/1.1\n`;
  try { out += `Host: ${new URL(r.url).host}\n`; } catch(e) {}
  for (const [k, v] of Object.entries(r.headers)) { out += `${k}: ${v}\n`; }
  out += `Mode: ${r.mode}\nRedirect: ${r.redirect}\nCache: ${r.cache}\n`;
  out += `Timestamp: ${r.timestamp}\n`;

  out += `\n=== RESPONSE ===\n`;
  const res = raw.response;
  if (res.status !== null) {
    out += `HTTP/1.1 ${res.status} ${res.statusText || ''}\n`;
    out += `Response-Type: ${res.type || 'N/A'}\nResponse-URL: ${res.url || 'N/A'}\n`;
    out += `Redirected: ${res.redirected}\nOK: ${res.ok}\n`;
    for (const [k, v] of Object.entries(res.headers)) { out += `${k}: ${v}\n`; }
    out += `\n--- Body (${res.bodyLength ? res.bodyLength.toLocaleString() + ' bytes' : 'empty'}) ---\n`;
    if (res.body) {
      let bodyText = res.body;
      try { bodyText = JSON.stringify(JSON.parse(res.body), null, 2); } catch(e) {}
      out += bodyText;
      if (res.bodyTruncated) out += `\n... [TRUNCATED — original ${res.bodyLength.toLocaleString()} bytes] ...`;
    } else {
      out += `[No body captured]`;
    }
  } else {
    out += `NO RESPONSE RECEIVED\n`;
    if (raw.error) {
      out += `Error: ${raw.error.name}: ${raw.error.message}\n`;
      if (raw.error.stack) out += `Stack: ${raw.error.stack}\n`;
    }
  }

  out += `\n\n=== TIMING ===\n`;
  const t = raw.timings;
  out += `Start: ${t.start || 'N/A'}\nHeaders: ${t.headersReceived != null ? t.headersReceived + 'ms' : 'N/A'}\n`;
  out += `Body: ${t.bodyReceived != null ? t.bodyReceived + 'ms' : 'N/A'}\nTotal: ${t.total != null ? t.total + 'ms' : 'N/A'}\n`;

  if (raw.noCors) {
    out += `\n=== NO-CORS FALLBACK ===\n`;
    if (raw.noCors.reachable) {
      out += `Reachable: true\nType: ${raw.noCors.type}\nTiming: ${raw.noCors.timing}ms\n`;
    } else {
      out += `Reachable: false\nError: ${raw.noCors.error}\n`;
    }
  }

  return out;
}

function copyRawData(id) {
  const testResult = RESULTS.tests.find(t => t.id === id);
  if (!testResult) return;
  const text = getRawPlainText(testResult.raw);
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById(`copy-raw-${id}`);
    if (btn) { const o = btn.textContent; btn.textContent = '✓ Copied'; setTimeout(() => btn.textContent = o, 1500); }
  });
}

function toggleRawPanel(id, panel) {
  const el = document.getElementById(`raw-${panel}-${id}`);
  const btn = document.getElementById(`btn-raw-${panel}-${id}`);
  if (el) {
    el.classList.toggle('open');
    if (btn) btn.classList.toggle('active');
  }
}

function renderTestDetails(id, result) {
  let html = '';

  // Connection info
  html += `<div class="detail-group">
    <div class="detail-group-title">Connection Details</div>
    <table class="detail-table">
      <tr><td>URL</td><td>${escHtml(result.url)}</td></tr>
      <tr><td>Status</td><td><span class="tag tag-${result.status}">${result.status}</span> ${result.httpStatus ? `HTTP ${result.httpStatus} ${escHtml(result.httpStatusText)}` : escHtml(result.error) || ''}</td></tr>
      <tr><td>Response Time</td><td>${result.timing}ms ${result.timing > 3000 ? '<span class="tag tag-warn">SLOW</span>' : ''}</td></tr>
      <tr><td>Redirected</td><td>${result.redirected ? `Yes → ${escHtml(result.redirectURL)}` : 'No'}</td></tr>
      ${result.details.noCorsReachable !== undefined ? `<tr><td>No-CORS Reachable</td><td>${result.details.noCorsReachable ? 'Yes (' + result.details.noCorsTime + 'ms)' : 'No — ' + escHtml(result.details.noCorsError || '')}</td></tr>` : ''}
      ${result.details.note ? `<tr><td>Note</td><td>${escHtml(result.details.note)}</td></tr>` : ''}
      ${result.details.bodyLength !== undefined ? `<tr><td>Body Length</td><td>${result.details.bodyLength.toLocaleString()} bytes</td></tr>` : ''}
      ${result.raw.timings.headersReceived != null ? `<tr><td>Time to Headers</td><td>${result.raw.timings.headersReceived}ms</td></tr>` : ''}
      ${result.raw.timings.bodyReceived != null ? `<tr><td>Time to Body</td><td>${result.raw.timings.bodyReceived}ms</td></tr>` : ''}
    </table>
  </div>`;

  // Response Headers
  const headerKeys = Object.keys(result.headers);
  if (headerKeys.length > 0) {
    html += `<div class="detail-group">
      <div class="detail-group-title">Response Headers (${headerKeys.length})</div>
      <table class="detail-table">`;
    for (const [k, v] of Object.entries(result.headers)) {
      const isProxy = result.proxyIndicators.some(p => p.header === k);
      html += `<tr><td>${escHtml(k)} ${isProxy ? '<span class="tag tag-warn">PROXY</span>' : ''}</td><td>${escHtml(v)}</td></tr>`;
    }
    html += `</table></div>`;
  }

  // Proxy indicators
  if (result.proxyIndicators.length > 0) {
    html += `<div class="detail-group">
      <div class="detail-group-title">⚠ Proxy / Firewall Indicators</div>
      <table class="detail-table">`;
    for (const p of result.proxyIndicators) {
      html += `<tr><td>${escHtml(p.header)}</td><td>${escHtml(p.value)}</td></tr>`;
    }
    html += `</table></div>`;
  }

  // SSL issues
  if (result.sslIssues.length > 0) {
    html += `<div class="detail-group">
      <div class="detail-group-title">⚠ SSL / TLS Observations</div>
      <table class="detail-table">`;
    for (const issue of result.sslIssues) {
      html += `<tr><td colspan="2">${escHtml(issue)}</td></tr>`;
    }
    html += `</table></div>`;
  }

  // Body preview (if openid config)
  if (result.details.bodyPreview && result.details.bodyPreview.startsWith('{')) {
    try {
      const json = JSON.parse(result.details.bodyPreview.length < 5000 ? result.details.bodyPreview : '{}');
      if (json.issuer || json.token_endpoint) {
        html += `<div class="detail-group">
          <div class="detail-group-title">OpenID Configuration (Verified)</div>
          <table class="detail-table">
            ${json.issuer ? `<tr><td>Issuer</td><td>${escHtml(json.issuer)}</td></tr>` : ''}
            ${json.token_endpoint ? `<tr><td>Token Endpoint</td><td>${escHtml(json.token_endpoint)}</td></tr>` : ''}
            ${json.authorization_endpoint ? `<tr><td>Authorize Endpoint</td><td>${escHtml(json.authorization_endpoint)}</td></tr>` : ''}
            ${json.device_authorization_endpoint ? `<tr><td>Device Auth Endpoint</td><td>${escHtml(json.device_authorization_endpoint)}</td></tr>` : ''}
          </table>
        </div>`;
      }
    } catch (e) {}
  }

  // Raw Request/Response toggle buttons
  html += `<div class="raw-toggles-bar">
    <button class="raw-toggle" id="btn-raw-req-${id}" onclick="toggleRawPanel('${id}', 'req')">▸ Raw Request</button>
    <button class="raw-toggle" id="btn-raw-res-${id}" onclick="toggleRawPanel('${id}', 'res')">▸ Raw Response</button>
    ${result.raw.noCors ? `<button class="raw-toggle" id="btn-raw-nocors-${id}" onclick="toggleRawPanel('${id}', 'nocors')">▸ No-CORS Fallback</button>` : ''}
    <button class="raw-copy-btn" id="copy-raw-${id}" onclick="copyRawData('${id}')">⎘ Copy All Raw Data</button>
  </div>`;

  // Raw Request panel
  html += `<div class="raw-panel" id="raw-req-${id}">
    <div class="raw-block">
      <div class="raw-block-header">
        <span class="raw-block-label req">⬆ REQUEST</span>
        <span class="raw-block-meta">${escHtml(result.raw.request.method)} · ${escHtml(result.raw.request.timestamp)}</span>
      </div>
      <div class="raw-block-body">${formatRawRequest(result.raw)}</div>
    </div>
  </div>`;

  // Raw Response panel
  const resLabel = result.raw.response.status !== null ?
    (result.raw.response.ok ? 'res' : 'res-err') : 'res-err';
  html += `<div class="raw-panel" id="raw-res-${id}">
    <div class="raw-block">
      <div class="raw-block-header">
        <span class="raw-block-label ${resLabel}">⬇ RESPONSE</span>
        <span class="raw-block-meta">${result.raw.response.status !== null ? `HTTP ${result.raw.response.status}` : 'ERROR'} · ${result.raw.response.bodyLength ? result.raw.response.bodyLength.toLocaleString() + ' bytes' : 'no body'}</span>
      </div>
      <div class="raw-block-body">${formatRawResponse(result.raw)}</div>
    </div>
  </div>`;

  // No-CORS fallback panel
  if (result.raw.noCors) {
    html += `<div class="raw-panel" id="raw-nocors-${id}">
      <div class="raw-block">
        <div class="raw-block-header">
          <span class="raw-block-label ${result.raw.noCors.reachable ? 'res' : 'res-err'}">⬇ NO-CORS FALLBACK</span>
          <span class="raw-block-meta">${result.raw.noCors.reachable ? 'Reachable · ' + result.raw.noCors.timing + 'ms' : 'Failed'}</span>
        </div>
        <div class="raw-block-body">${formatRawNoCors(result.raw.noCors)}</div>
      </div>
    </div>`;
  }

  document.getElementById(`details-${id}`).innerHTML = html;
}

// SSL Inspection Detection test
async function testSSLInspection() {
  const result = {
    id: 'ssl-inspection',
    name: 'SSL Inspection Detection',
    status: 'pending',
    findings: []
  };

  log('Running SSL inspection detection...', 'info');

  // Test 1: Certificate transparency check via headers
  try {
    const resp = await fetch('https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration', {
      cache: 'no-store',
      signal: AbortSignal.timeout(10000)
    });

    // Check for headers that indicate SSL inspection
    const suspectHeaders = [];
    resp.headers.forEach((val, key) => {
      const kl = key.toLowerCase();
      if (kl === 'via' || kl.includes('proxy') || kl.includes('x-bluecoat') ||
          kl.includes('x-zscaler') || kl.includes('x-fortinet') || kl.includes('x-palo') ||
          kl.includes('x-sophos') || kl.includes('x-squid') || kl.includes('x-barracuda')) {
        suspectHeaders.push(`${key}: ${val}`);
      }
    });

    if (suspectHeaders.length > 0) {
      result.findings.push({
        type: 'critical',
        msg: `Proxy/SSL inspection headers detected: ${suspectHeaders.join(', ')}`
      });
    }

    // Test 2: Timing comparison - SSL inspection adds significant latency
    const timings = [];
    for (let i = 0; i < 3; i++) {
      const s = performance.now();
      await fetch('https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration', {
        cache: 'no-store',
        mode: 'cors',
        signal: AbortSignal.timeout(10000)
      });
      timings.push(performance.now() - s);
    }
    const avgTime = timings.reduce((a, b) => a + b) / timings.length;
    const variance = Math.max(...timings) - Math.min(...timings);

    result.findings.push({
      type: avgTime > 2000 ? 'warning' : 'info',
      msg: `Avg latency to login.microsoftonline.com: ${Math.round(avgTime)}ms (variance: ${Math.round(variance)}ms) ${avgTime > 2000 ? '— HIGH: possible SSL inspection' : '— Normal range'}`
    });

  } catch (e) {
    result.findings.push({
      type: 'critical',
      msg: `Cannot reach login.microsoftonline.com: ${e.message} — likely blocked or SSL inspection breaking connection`
    });
  }

  // Test 3: Check if SecurityPolicy API is available (reports cert info)
  if (window.SecurityPolicyViolationEvent) {
    result.findings.push({
      type: 'info',
      msg: 'SecurityPolicyViolationEvent supported — CSP violations will be detectable'
    });
  }

  result.status = result.findings.some(f => f.type === 'critical') ? 'fail' :
                  result.findings.some(f => f.type === 'warning') ? 'warn' : 'pass';

  return result;
}

// Redirect chain test
async function testRedirectBehavior() {
  const result = {
    id: 'redirect-test',
    name: 'Redirect Chain Test',
    status: 'pending',
    findings: []
  };

  log('Testing redirect chain behavior...', 'info');

  // Test various redirect scenarios
  const redirectTests = [
    {
      name: 'Admin Consent Redirect',
      url: 'https://login.microsoftonline.com/common/adminconsent?client_id=test&redirect_uri=https://localhost'
    },
    {
      name: 'OAuth Authorize Redirect',
      url: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=test&response_type=code&redirect_uri=https://localhost&scope=openid'
    }
  ];

  for (const test of redirectTests) {
    try {
      const start = performance.now();
      const resp = await fetch(test.url, {
        redirect: 'manual',
        mode: 'no-cors',
        cache: 'no-store',
        signal: AbortSignal.timeout(10000)
      });
      const elapsed = performance.now() - start;

      result.findings.push({
        type: 'info',
        msg: `${test.name}: Response type=${resp.type}, status=${resp.status}, time=${Math.round(elapsed)}ms`
      });

      // opaqueredirect is EXPECTED for manual redirect + no-cors
      if (resp.type === 'opaqueredirect' || resp.status === 0 || resp.status === 302) {
        result.findings.push({
          type: 'info',
          msg: `${test.name}: Redirect behavior appears normal`
        });
      }
    } catch (e) {
      result.findings.push({
        type: 'warning',
        msg: `${test.name}: ${e.message} — redirect may be blocked`
      });
    }
  }

  result.status = result.findings.some(f => f.type === 'critical') ? 'fail' :
                  result.findings.some(f => f.type === 'warning') ? 'warn' : 'pass';

  return result;
}

// WebSocket connectivity test (some firewalls block WS which affects SignalR)
async function testWebSocket() {
  return new Promise(resolve => {
    const result = { id: 'websocket', findings: [] };
    try {
      const ws = new WebSocket('wss://login.microsoftonline.com');
      const timeout = setTimeout(() => {
        ws.close();
        result.findings.push({ type: 'info', msg: 'WebSocket connection timed out (normal for this endpoint)' });
        result.status = 'pass';
        resolve(result);
      }, 5000);

      ws.onopen = () => {
        clearTimeout(timeout);
        ws.close();
        result.findings.push({ type: 'info', msg: 'WebSocket connection established' });
        result.status = 'pass';
        resolve(result);
      };

      ws.onerror = (e) => {
        clearTimeout(timeout);
        result.findings.push({ type: 'info', msg: 'WebSocket rejected (expected for auth endpoint)' });
        result.status = 'pass';
        resolve(result);
      };
    } catch (e) {
      result.findings.push({ type: 'warning', msg: `WebSocket blocked: ${e.message}` });
      result.status = 'warn';
      resolve(result);
    }
  });
}

function generateFindings() {
  const findings = [];
  const tests = RESULTS.tests;

  // Check for blocked critical endpoints
  const blockedCritical = tests.filter(t => t.critical && t.status === 'fail');
  if (blockedCritical.length > 0) {
    findings.push({
      type: 'critical',
      title: 'Critical Endpoints Blocked',
      msg: `${blockedCritical.length} critical endpoint(s) are unreachable: ${blockedCritical.map(t => t.name).join(', ')}. These are required for Azure AD authentication and OAuth flows. A firewall or proxy is likely blocking these connections.`
    });
  }

  // Check for proxy indicators
  const withProxy = tests.filter(t => t.proxyIndicators && t.proxyIndicators.length > 0);
  if (withProxy.length > 0) {
    const allHeaders = withProxy.flatMap(t => t.proxyIndicators.map(p => p.header));
    const uniqueHeaders = [...new Set(allHeaders)];
    findings.push({
      type: 'critical',
      title: 'Proxy/Firewall Detected in Request Path',
      msg: `${withProxy.length} endpoint(s) show proxy/firewall headers: ${uniqueHeaders.join(', ')}. This confirms traffic is being intercepted and possibly modified. Request SSL inspection bypass for Microsoft authentication domains.`
    });
  }

  // Check for SSL inspection indicators (high latency)
  const slowEndpoints = tests.filter(t => t.timing > 3000);
  if (slowEndpoints.length >= 3) {
    findings.push({
      type: 'warning',
      title: 'High Latency Detected — Possible SSL Inspection',
      msg: `${slowEndpoints.length} endpoints show response times >3000ms. This pattern is consistent with SSL/TLS inspection (decryption + re-encryption adds latency). Endpoints: ${slowEndpoints.map(t => `${t.name} (${t.timing}ms)`).join(', ')}.`
    });
  }

  // Check for mixed results (some pass, some fail) - suggests selective filtering
  const passCount = tests.filter(t => t.status === 'pass').length;
  const failCount = tests.filter(t => t.status === 'fail').length;
  if (passCount > 0 && failCount > 0) {
    findings.push({
      type: 'warning',
      title: 'Selective Filtering Detected',
      msg: `Some endpoints are accessible while others are blocked. This suggests URL-level or domain-level filtering rules rather than a blanket block. The firewall may be allowing general Microsoft traffic but blocking specific OAuth/admin consent URLs.`
    });
  }

  // Check OAuth-specific endpoints
  const oauthTests = tests.filter(t => t.category === 'oauth');
  const oauthFailed = oauthTests.filter(t => t.status === 'fail');
  if (oauthFailed.length > 0) {
    findings.push({
      type: 'critical',
      title: 'OAuth Flow Endpoints Blocked',
      msg: `OAuth-specific endpoints are blocked: ${oauthFailed.map(t => t.name).join(', ')}. This directly prevents the admin consent flow from completing. The token exchange and/or authorization redirect is being intercepted.`
    });
  }

  // Check device login specifically
  const deviceLogin = tests.find(t => t.id === 'device-login');
  if (deviceLogin && deviceLogin.status === 'fail') {
    findings.push({
      type: 'critical',
      title: 'Device Login Endpoint Blocked',
      msg: 'device.login.microsoftonline.com is unreachable. This endpoint is specifically required for the device code authentication flow. This is likely the primary cause of the AADSTS50097 error when the device auth fallback fails inside the corporate network.'
    });
  }

  // Check body content for firewall pages
  const firewallPages = tests.filter(t => t.sslIssues && t.sslIssues.some(s => s.includes('firewall') || s.includes('proxy')));
  if (firewallPages.length > 0) {
    findings.push({
      type: 'critical',
      title: 'Firewall Block Pages Detected',
      msg: `${firewallPages.length} endpoint(s) returned content containing firewall/proxy block page indicators instead of legitimate Microsoft responses. This confirms the firewall is actively intercepting and blocking these requests.`
    });
  }

  // Check for CORS-only issues (endpoint reachable but CORS blocked = normal)
  const corsOnly = tests.filter(t => t.status === 'pass' && t.details.noCorsReachable === true);
  if (corsOnly.length > 0) {
    findings.push({
      type: 'info',
      title: 'CORS Restrictions (Normal Behavior)',
      msg: `${corsOnly.length} endpoint(s) block direct browser CORS requests but are fully reachable. This is expected — OAuth endpoints (token, authorize, admin consent) use server-side calls and browser redirects, not direct AJAX requests. No action needed.`
    });
  }

  // All pass
  if (failCount === 0 && !findings.some(f => f.type === 'critical')) {
    findings.push({
      type: 'info',
      title: '✓ Network Path is Clean',
      msg: 'All Microsoft authentication and API endpoints are reachable from this network with no proxy/firewall interference detected. No SSL inspection detected. If the OAuth admin consent flow is still failing from this network, the issue is likely in Azure AD configuration (Conditional Access policies, Security Defaults, Protected Actions, or device compliance requirements) rather than network-level blocking. Run this same test from the OTHER network to compare results.'
    });
  }

  // Add SSL inspection test results
  if (RESULTS.sslTest) {
    for (const f of RESULTS.sslTest.findings) {
      findings.push({
        type: f.type === 'critical' ? 'critical' : f.type === 'warning' ? 'warning' : 'info',
        title: 'SSL Inspection Analysis',
        msg: f.msg
      });
    }
  }

  // Add proxy detection findings
  if (RESULTS.proxyDetection) {
    const pd = RESULTS.proxyDetection;
    if (pd.detectedIndicators >= 3) {
      findings.push({
        type: 'critical',
        title: 'Proxy / Network Interception Detected',
        msg: `${pd.detectedIndicators} of ${pd.totalChecks} proxy indicators triggered. ${pd.summary}. Detected checks: ${pd.checks.filter(c => c.status === 'detected').map(c => c.name).join(', ')}. This is very likely interfering with the OAuth admin consent flow. Request IT to bypass proxy for Microsoft authentication endpoints.`
      });
    } else if (pd.detectedIndicators >= 1) {
      findings.push({
        type: 'warning',
        title: 'Possible Proxy / Network Interception',
        msg: `${pd.detectedIndicators} of ${pd.totalChecks} proxy indicators triggered: ${pd.checks.filter(c => c.status === 'detected').map(c => c.name).join(', ')}. This may be affecting the OAuth admin consent flow.`
      });
    } else {
      findings.push({
        type: 'info',
        title: 'No Proxy Detected',
        msg: `All ${pd.totalChecks} proxy detection checks are clear. No evidence of proxy, WPAD, SSL interception, or protocol downgrade from this network.`
      });
    }

    // HTTP/1.1 downgrade is especially critical
    const protocolCheck = pd.checks.find(c => c.name === 'HTTP Protocol Negotiation' && c.status === 'detected');
    if (protocolCheck) {
      findings.push({
        type: 'critical',
        title: 'HTTP Protocol Downgrade Detected',
        msg: 'Microsoft endpoints are being served over HTTP/1.1 instead of HTTP/2. This is a strong indicator of an intercepting proxy or firewall performing SSL inspection, as the TLS-ALPN negotiation is being broken by the middlebox.'
      });
    }

    // Body integrity issues
    const integrityCheck = pd.checks.find(c => c.name === 'Response Body Integrity' && c.status === 'detected');
    if (integrityCheck) {
      findings.push({
        type: 'critical',
        title: 'Response Body Tampering Detected',
        msg: 'The OpenID Configuration response from Microsoft has been modified or replaced. This means a proxy or firewall is actively altering Azure AD responses, which will break OAuth token exchange and admin consent flows.'
      });
    }
  }

  // Add redirect test results
  if (RESULTS.redirectTest) {
    for (const f of RESULTS.redirectTest.findings.filter(f => f.type !== 'info')) {
      findings.push({
        type: f.type === 'critical' ? 'critical' : 'warning',
        title: 'Redirect Behavior',
        msg: f.msg
      });
    }
  }

  RESULTS.findings = findings;

  // Render findings
  const panel = document.getElementById('findingsPanel');
  const list = document.getElementById('findingsList');
  list.innerHTML = '';

  if (findings.length > 0) {
    panel.classList.add('active');
    for (const f of findings) {
      const cls = f.type === 'critical' ? 'finding-critical' : f.type === 'warning' ? 'finding-warning' : 'finding-info';
      list.innerHTML += `<div class="finding-item ${cls}"><strong>${f.title || ''}</strong>${f.msg}</div>`;
    }
  }
}

async function runAllTests() {
  const btn = document.getElementById('btnRun');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Running...';

  // Reset
  document.getElementById('testSections').innerHTML = '';
  document.getElementById('findingsList').innerHTML = '';
  document.getElementById('findingsPanel').classList.remove('active');
  document.getElementById('rawLog').innerHTML = '';
  RESULTS.tests = [];
  RESULTS.findings = [];
  RESULTS.timestamp = new Date().toISOString();

  const totalTests = ENDPOINTS.length + 4; // endpoints + ssl + redirect + websocket + proxy
  let completed = 0;

  document.getElementById('progressContainer').classList.add('active');
  document.getElementById('summaryGrid').classList.add('active');

  // Phase 1: Environment
  log('═══ PHASE 1: Environment Collection ═══', 'info');
  updateProgress(0, totalTests, 'Collecting environment data...');
  collectEnvironment();
  await detectPublicIP();

  // Phase 2: Create all sections
  ENDPOINTS.forEach(ep => createTestSection(ep));

  // Phase 3: Run endpoint tests
  log('\n═══ PHASE 2: Endpoint Connectivity Tests ═══', 'info');

  for (const endpoint of ENDPOINTS) {
    updateProgress(completed, totalTests, `Testing ${endpoint.name}...`);
    const result = await testEndpoint(endpoint);
    RESULTS.tests.push(result);
    completed++;
    updateSummary();
  }

  // Phase 4: Proxy Detection (runs after endpoints so it can analyze their headers)
  log('\n═══ PHASE 3: Proxy & Network Interception Detection ═══', 'info');
  updateProgress(completed, totalTests, 'Detecting proxy configuration...');
  await detectProxyConfiguration();
  completed++;

  // Phase 5: SSL Inspection test
  log('\n═══ PHASE 4: SSL Inspection Detection ═══', 'info');
  updateProgress(completed, totalTests, 'Analyzing SSL inspection...');
  RESULTS.sslTest = await testSSLInspection();
  completed++;

  // Phase 5: Redirect test
  log('\n═══ PHASE 4: Redirect Chain Analysis ═══', 'info');
  updateProgress(completed, totalTests, 'Testing redirect behavior...');
  RESULTS.redirectTest = await testRedirectBehavior();
  completed++;

  // Phase 6: WebSocket test
  log('\n═══ PHASE 5: WebSocket Connectivity ═══', 'info');
  updateProgress(completed, totalTests, 'Testing WebSocket...');
  RESULTS.wsTest = await testWebSocket();
  completed++;

  // Phase 7: Generate findings
  log('\n═══ PHASE 6: Generating Diagnostic Report ═══', 'info');
  updateProgress(totalTests, totalTests, 'Complete!');
  generateFindings();

  // Show export buttons
  document.getElementById('btnExportJson').style.display = '';
  document.getElementById('btnExportText').style.display = '';
  document.getElementById('btnCopy').style.display = '';

  // Auto-expand failed tests
  RESULTS.tests.filter(t => t.status === 'fail').forEach(t => {
    document.getElementById(`body-${t.id}`).classList.add('open');
    document.getElementById(`chev-${t.id}`).classList.add('open');
  });

  btn.disabled = false;
  btn.innerHTML = '▶ Run Again';

  log('\n═══ DIAGNOSTIC COMPLETE ═══', 'pass');
  log(`Summary: ${RESULTS.summary.pass} passed, ${RESULTS.summary.warn} warnings, ${RESULTS.summary.fail} failed`, RESULTS.summary.fail > 0 ? 'fail' : 'pass');
}

function updateSummary() {
  const tests = RESULTS.tests;
  const s = {
    total: tests.length,
    pass: tests.filter(t => t.status === 'pass').length,
    warn: tests.filter(t => t.status === 'warn').length,
    fail: tests.filter(t => t.status === 'fail').length
  };
  RESULTS.summary = s;
  document.getElementById('sumTotal').textContent = s.total;
  document.getElementById('sumPass').textContent = s.pass;
  document.getElementById('sumWarn').textContent = s.warn;
  document.getElementById('sumFail').textContent = s.fail;
}

function exportJSON() {
  const blob = new Blob([JSON.stringify(RESULTS, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `azure-oauth-diag-${new Date().toISOString().slice(0, 16).replace(/:/g, '-')}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function generateTextReport() {
  let report = '';
  report += '╔══════════════════════════════════════════════════════════╗\n';
  report += '║       AZURE OAUTH NETWORK DIAGNOSTIC REPORT            ║\n';
  report += '╚══════════════════════════════════════════════════════════╝\n\n';
  report += `Generated: ${RESULTS.timestamp}\n`;
  report += `Summary: ${RESULTS.summary.pass} PASS | ${RESULTS.summary.warn} WARN | ${RESULTS.summary.fail} FAIL\n\n`;

  report += '── ENVIRONMENT ──────────────────────────────────────────\n';
  for (const [k, v] of Object.entries(RESULTS.environment)) {
    report += `  ${k}: ${v}\n`;
  }

  report += '\n── ENDPOINT TESTS ──────────────────────────────────────\n';
  for (const t of RESULTS.tests) {
    const icon = t.status === 'pass' ? '✓' : t.status === 'warn' ? '⚠' : '✕';
    report += `\n  ${icon} ${t.name} [${t.status.toUpperCase()}]\n`;
    report += `    URL: ${t.url}\n`;
    report += `    HTTP: ${t.httpStatus || 'N/A'} | Time: ${t.timing}ms | Redirected: ${t.redirected}\n`;
    if (t.error) report += `    Error: ${t.error}\n`;
    if (t.proxyIndicators.length > 0) {
      report += `    ⚠ Proxy Indicators:\n`;
      t.proxyIndicators.forEach(p => report += `      ${p.header}: ${p.value}\n`);
    }
    if (t.sslIssues.length > 0) {
      report += `    ⚠ SSL Issues:\n`;
      t.sslIssues.forEach(s => report += `      ${s}\n`);
    }
    if (Object.keys(t.headers).length > 0) {
      report += `    Response Headers:\n`;
      for (const [k, v] of Object.entries(t.headers)) {
        report += `      ${k}: ${v}\n`;
      }
    }

    // Raw Request/Response
    if (t.raw) {
      report += `\n    ── RAW REQUEST ──\n`;
      report += `    ${t.raw.request.method} ${t.raw.request.url} HTTP/1.1\n`;
      try { report += `    Host: ${new URL(t.raw.request.url).host}\n`; } catch(e) {}
      for (const [k, v] of Object.entries(t.raw.request.headers)) {
        report += `    ${k}: ${v}\n`;
      }
      report += `    Mode: ${t.raw.request.mode} | Redirect: ${t.raw.request.redirect} | Cache: ${t.raw.request.cache}\n`;
      report += `    Timestamp: ${t.raw.request.timestamp}\n`;

      report += `\n    ── RAW RESPONSE ──\n`;
      const res = t.raw.response;
      if (res.status !== null) {
        report += `    HTTP/1.1 ${res.status} ${res.statusText || ''}\n`;
        report += `    Response-Type: ${res.type || 'N/A'} | Response-URL: ${res.url || 'N/A'}\n`;
        report += `    Redirected: ${res.redirected} | OK: ${res.ok}\n`;
        for (const [k, v] of Object.entries(res.headers)) {
          report += `    ${k}: ${v}\n`;
        }
        report += `\n    --- Body (${res.bodyLength ? res.bodyLength.toLocaleString() + ' bytes' : 'empty'}) ---\n`;
        if (res.body) {
          let bodyText = res.body;
          try { bodyText = JSON.stringify(JSON.parse(res.body), null, 2); } catch(e) {}
          if (bodyText.length > 5000) {
            report += `    ${bodyText.substring(0, 5000).split('\n').join('\n    ')}\n    ... [TRUNCATED in text report — ${res.bodyLength.toLocaleString()} bytes total, full data in JSON export] ...\n`;
          } else {
            report += `    ${bodyText.split('\n').join('\n    ')}\n`;
          }
        } else {
          report += `    [No body captured]\n`;
        }
      } else {
        report += `    NO RESPONSE RECEIVED\n`;
        if (t.raw.error) {
          report += `    Error: ${t.raw.error.name}: ${t.raw.error.message}\n`;
        }
      }

      report += `\n    ── TIMING ──\n`;
      const tm = t.raw.timings;
      report += `    Start: ${tm.start || 'N/A'} | Headers: ${tm.headersReceived != null ? tm.headersReceived + 'ms' : 'N/A'} | Body: ${tm.bodyReceived != null ? tm.bodyReceived + 'ms' : 'N/A'} | Total: ${tm.total != null ? tm.total + 'ms' : 'N/A'}\n`;

      if (t.raw.noCors) {
        report += `\n    ── NO-CORS FALLBACK ──\n`;
        if (t.raw.noCors.reachable) {
          report += `    Reachable: true | Type: ${t.raw.noCors.type} | Timing: ${t.raw.noCors.timing}ms\n`;
        } else {
          report += `    Reachable: false | Error: ${t.raw.noCors.error}\n`;
        }
      }
    }

    report += `\n    ─────────────────────────────────────────────────\n`;
  }

  report += '\n── FINDINGS ────────────────────────────────────────────\n';
  for (const f of RESULTS.findings) {
    const icon = f.type === 'critical' ? '🔴' : f.type === 'warning' ? '🟡' : '🔵';
    report += `\n  ${icon} ${f.title || ''}\n`;
    report += `    ${f.msg}\n`;
  }

  // Proxy Detection Details
  if (RESULTS.proxyDetection) {
    report += '\n── PROXY DETECTION ─────────────────────────────────────\n';
    report += `  Summary: ${RESULTS.proxyDetection.summary}\n`;
    report += `  Indicators: ${RESULTS.proxyDetection.detectedIndicators}/${RESULTS.proxyDetection.totalChecks}\n`;
    report += `  Detection Time: ${RESULTS.proxyDetection.timing}ms\n`;

    for (const check of RESULTS.proxyDetection.checks) {
      const icon = check.status === 'detected' ? '⚠' : check.status === 'clear' ? '✓' : check.status === 'error' ? '✕' : 'ℹ';
      report += `\n  ${icon} ${check.name} [${check.status.toUpperCase()}]\n`;
      report += `    ${check.detail.split('\n').join('\n    ')}\n`;
    }

    if (RESULTS.proxyDetection.localIPs && RESULTS.proxyDetection.localIPs.length > 0) {
      report += `\n  Local IPs: ${RESULTS.proxyDetection.localIPs.join(', ')}\n`;
    }

    if (RESULTS.proxyDetection.resourceTiming) {
      const rt = RESULTS.proxyDetection.resourceTiming;
      report += `\n  Resource Timing Breakdown:\n`;
      report += `    DNS: ${rt.dns}ms | TCP: ${rt.tcp}ms | SSL: ${rt.ssl}ms | TTFB: ${rt.ttfb}ms | Download: ${rt.download}ms | Total: ${rt.total}ms\n`;
      report += `    Protocol: ${rt.nextHopProtocol} | Transfer: ${rt.transferSize} bytes\n`;
    }
  }

  report += '\n── END OF REPORT ───────────────────────────────────────\n';
  return report;
}

function exportText() {
  const report = generateTextReport();
  const blob = new Blob([report], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `azure-oauth-diag-${new Date().toISOString().slice(0, 16).replace(/:/g, '-')}.txt`;
  a.click();
  URL.revokeObjectURL(url);
}

function copyReport() {
  const report = generateTextReport();
  navigator.clipboard.writeText(report).then(() => {
    const btn = document.getElementById('btnCopy');
    const orig = btn.innerHTML;
    btn.innerHTML = '✓ Copied!';
    setTimeout(() => btn.innerHTML = orig, 2000);
  });
}
</script>

</body>
</html>
